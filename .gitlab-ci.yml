stages:
  - validate
  - infrastructure
  - deploy
  - test
  - destroy

variables:
  CLUSTER_NAME: "axual-demo-cluster"
  AZURE_REGION: "eastus"
  RESOURCE_GROUP: "axual-demo-cluster-rg"
  MYSQL_ROOT_PASSWORD: "DemoPassword123!"
  MYSQL_DATABASE: "test"
  MYSQL_USER: "test"
  MYSQL_PASSWORD: "test123"

image: alpine:latest

.setup_tools: &setup_tools |
  apk add --no-cache python3 py3-pip curl wget unzip bash ca-certificates
  pip3 install azure-cli --break-system-packages
  curl -LO "https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl"
  chmod +x kubectl && mv kubectl /usr/local/bin/
  curl -LO "https://get.helm.sh/helm-v3.17.0-linux-amd64.tar.gz"
  tar -zxvf helm-v3.17.0-linux-amd64.tar.gz && mv linux-amd64/helm /usr/local/bin/
  az login --service-principal -u ${AZURE_CLIENT_ID} -p ${AZURE_CLIENT_SECRET} --tenant ${AZURE_TENANT_ID}
  az account set --subscription ${AZURE_SUBSCRIPTION_ID}

.setup_terraform: &setup_terraform |
  wget -O terraform.zip "https://releases.hashicorp.com/terraform/1.13.5/terraform_1.13.5_linux_amd64.zip"
  unzip -o terraform.zip -d /usr/local/bin/
  chmod +x /usr/local/bin/terraform

validate_terraform:
  stage: validate
  when: manual
  before_script:
    - *setup_tools
    - *setup_terraform
  script:
    - cd terraform
    - terraform init
    - terraform validate
    - terraform plan -out=plan.tfplan
  artifacts:
    paths:
      - terraform/plan.tfplan
    expire_in: 1 hour
  only:
    - main
    - merge_requests

deploy_infrastructure:
  stage: infrastructure
  when: manual
  before_script:
    - *setup_tools
    - *setup_terraform
  script:
    - cd terraform
    - terraform init
    - terraform apply -input=false plan.tfplan
    - echo "Waiting for AKS cluster to be ready..."
    - sleep 60
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing
    - kubectl get nodes
  dependencies:
    - validate_terraform
  only:
    - main

deploy_prerequisites:
  stage: deploy
  before_script:
    - *setup_tools
  script:
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing
    - kubectl apply -f helm/azure-disk-sc.yaml
    - kubectl get storageclass
  dependencies:
    - deploy_infrastructure
  only:
    - main

deploy_mysql:
  stage: deploy
  before_script:
    - *setup_tools
  script:
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing
    - kubectl create namespace mysql --dry-run=client -o yaml | kubectl apply -f -
    - helm repo add bitnami https://charts.bitnami.com/bitnami
    - helm repo update
    - |
      helm upgrade --install mysql bitnami/mysql \
        --namespace mysql \
        --values helm/mysql-values.yaml \
        --set auth.rootPassword="${MYSQL_ROOT_PASSWORD}" \
        --set auth.database="${MYSQL_DATABASE}" \
        --set auth.username="${MYSQL_USER}" \
        --set auth.password="${MYSQL_PASSWORD}" \
        --wait --timeout=10m
    - kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=mysql -n mysql --timeout=600s
  dependencies:
    - deploy_prerequisites
  only:
    - main

deploy_app:
  stage: deploy
  before_script:
    - *setup_tools
  script:
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing
    - kubectl create namespace myapp --dry-run=client -o yaml | kubectl apply -f -
    - helm upgrade --install myapp helm --namespace myapp --values helm/myapp-values.yaml --set service.type=LoadBalancer
    - kubectl wait --for=condition=ready pod -l app=my-app -n myapp --timeout=300s
    - echo "Waiting for LoadBalancer IP..."
    - sleep 30
    - kubectl get svc -n myapp
  dependencies:
    - deploy_mysql
  only:
    - main

smoke_tests:
  stage: test
  before_script:
    - *setup_tools
  script:
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing
    - kubectl get pods -n mysql
    - kubectl get pods -n myapp
    - kubectl get pvc -A
    - kubectl get svc -A
    - echo "Getting LoadBalancer IP..."
    - kubectl get svc -n myapp -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}'
  dependencies:
    - deploy_app
  only:
    - main

cleanup_k8s_resources:
  stage: destroy
  when: manual
  before_script:
    - *setup_tools
  script:
    - az aks get-credentials --resource-group ${RESOURCE_GROUP} --name ${CLUSTER_NAME} --overwrite-existing || true
    - echo "Deleting Helm releases..."
    - helm uninstall myapp -n myapp --wait || true
    - helm uninstall mysql -n mysql --wait || true
    - echo "Waiting for services to be deleted..."
    - sleep 30
    - echo "Force deleting namespaces..."
    - kubectl delete namespace myapp --force --grace-period=0 || true
    - kubectl delete namespace mysql --force --grace-period=0 || true
    - kubectl delete sc azure-disk-premium || true
    - echo "Waiting for LoadBalancers to be deleted..."
    - sleep 60
    - echo "Checking remaining resources..."
    - kubectl get svc -A || true
    - kubectl get pvc -A || true
  only:
    - main

destroy_infrastructure:
  stage: destroy
  when: manual
  needs:
    - cleanup_k8s_resources
  before_script:
    - *setup_tools
    - *setup_terraform
  script:
    - cd terraform
    - terraform init
    - echo "Checking what will be destroyed..."
    - terraform plan -destroy
    - echo "Starting infrastructure destruction..."
    - terraform destroy -auto-approve
    - echo "All Azure resources destroyed!"
  only:
    - main